"""
Обработка сетевых пакетов
Реализовать обработчик сетевых пакетов.
Вход. Размер буфера size и число пакетов n, а так-
же две последовательности arrival1; : : : ; arrivaln и
duration1; : : : ; durationn, обозначающих время поступ-
ления и длительность обработки n пакетов.
Выход. Для каждого из данных n пакетов необходимо
вывести время начала его обработки или -1, если пакет
не был обработан (это происходит в случае, когда пакет
поступает в момент, когда в буфере компьютера уже
находится size пакетов).

Ваша цель—реализовать симу-
лятор обработки сетевых пакетов.
Для i-го пакета известно время его
поступления arrivali, а также вре-
мя durationi, необходимое на его
обработку. В вашем распоряжении
имеется один процессор, который
обрабатывает пакеты в порядке их
поступления. Если процессор на-
чинает обрабатывать пакет i (что
занимает время durationi), он не прерывается и не останавливается
до тех пор, пока не обработает пакет.
У компьютера, обрабатывающего пакеты, имеется сетевой буфер
размера size. До начала обработки пакеты хранятся в буфере. Если бу-
фер полностью заполнен в момент поступления пакета (есть size па-
кетов, поступивших ранее, которые до сих пор не обработаны), этот
пакет отбрасывается и уже не будет обработан. Если несколько паке-
тов поступает в одно и то же время, они все будут сперва сохранены в
буфер (несколько последних из них могут быть отброшены, если бу-
фер заполнится).
Компьютер обрабатывает пакеты в порядке их поступления. Он
начинает обрабатывать следующий пакет из буфера сразу после того,
как обработает текущий пакет. Компьютер может простаивать, если
все пакеты уже обработаны и в буфере нет пакетов. Пакет освобожда-
ет место в буфере сразуже, как компьютер заканчивает его обработку.

Формат входа. Первая строка входа содержит размер буфера size и
число пакетов n. Каждая из следующих n строк содержит два
числа: время arrivali прибытия i-го пакета и время durationi,
необходимое на его обработку.
Гарантируется, что arrival1 <= arrival2 <= ... <= arrivaln. При этом может оказаться, что
arrivali-1 = arrivali. В таком случае считаем, что пакет i - 1 по-
ступил раньше пакета i.

Формат выхода. Для каждого из n пакетов выведите время, когда
процессор начал его обрабатывать, или -1, если пакет был от-
брошен.
Ограничения. Все числа во входе целые. 1 <= size <= 10^5; 0 <= n <= 10^5;
0 <= arrivali <= 10^6; 0 <= durationi <= 10^3; arrivali <= arrivali+1 для всех
1 <= i <= n - 1.

Пример.
Вход:
1 0
Выход:
Если пакетов нет, выводить ничего не нужно.
Пример.
Вход:
1 1
0 0
Выход:
0
Пакет поступил в момент времени 0, и компьютер тут же начал
его обрабатывать.
Пример.
Вход:
1 2
0 1
0 1
Выход:
0
-1
Первый пакет поступил в момент времени 0, второй пакет по-
ступил также в момент времени 0, но был отброшен, посколь-
ку буфер в этот момент полностью заполнен (первым пакетом).
Первый пакет начал обрабатываться в момент времени 0, вто-
рой был отброшен.
Пример.
Вход:
1 2
0 1
1 1
Выход:
0
1
"""
from collections import deque, namedtuple


def main():
    size, n = (int(_) for _ in input().split())
    if n == 0:
        return
    Packet = namedtuple('Packet', ['arrival', 'duration'])
    packets = []
    for i in range(n):
        packets.append(Packet(*(int(_) for _ in input().split())))
    inf = 10 ** 7
    current_processing_ending = inf
    queue = deque()
    for packet in packets:
        while packet.arrival >= current_processing_ending:
            queue.popleft()
            if queue:
                current_processing_ending += queue[0].duration
            else:
                current_processing_ending = inf
        if len(queue) < size:
            if queue:
                print(packet_processing_start)
                packet_processing_start += packet.duration
            else:
                current_processing_ending = packet.arrival + packet.duration
                packet_processing_start = current_processing_ending
                print(packet.arrival)
            queue.append(packet)
        else:
            print(-1)


if __name__ == '__main__':
    main()
