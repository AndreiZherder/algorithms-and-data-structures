"""
Скобки в коде
Проверить, правильно ли расставлены скобки в данном коде.
Вход. Исходный код программы.
Выход. Проверить, верно ли расставлены скобки. Если нет,
выдать индекс первой ошибки.

Вы разрабатываете текстовый редактор для
программистов и хотите реализовать проверку
корректности расстановки скобок. В коде могут
встречаться скобки []{}(). Из них скобки [,{
и ( считаются открывающими, а соответству-
ющими им закрывающими скобками являются
],} и ).

В случае, если скобки расставлены неправильно, редактор должен
также сообщить пользователю первое место, где обнаружена ошибка.
В первую очередь необходимо найти закрывающую скобку, для кото-
рой либо нет соответствующей открывающей (например, скобка ] в
строке “]()”), либо же она закрывает не соответствующую ей откры-
вающую скобку (пример: “()[}”).

Если таких ошибок нет, необходи-
мо найти первую открывающую скобку, для которой нет соответству-
ющей закрывающей (пример: скобка ( в строке “{}([]”).

Помимо скобок, исходный код может содержать символы латин-
ского алфавита, цифры и знаки препинания.

Формат входа. Строка s[1 : : : n], состоящая из заглавных и пропис-
ных букв латинского алфавита, цифр, знаков препинания и ско-
бок из множества []{}().
Формат выхода. Если скобки в s расставлены правильно, выведите
строку “Success". В противном случае выведите индекс (исполь-
зуя индексацию с единицы) первой закрывающей скобки, для
которой нет соответствующей открывающей. Если такой нет,
выведите индекс первой открывающей скобки, для которой нет
соответствующей закрывающей.

Ограничения. 1 <= n <= 10^5.
Пример.
Вход:
[]
Выход:
Success

Пример.
Вход:
{}[]
Выход:
Success

Пример.
Вход:
[()]
Выход:
Success

Пример.
Вход:
(())
Выход:
Success

Пример.
Вход:
{[]}()
Выход:
Success

7
Пример.
Вход:
{
Выход:
1

Пример.
Вход:
{[}
Выход:
3

Пример.
Вход:
foo(bar);
Выход:
Success

Пример.
Вход:
foo(bar[i);
Выход:
10
"""


def check_parenthesis(s: str) -> int:
    d1 = {'[': ']', '{': '}', '(': ')'}
    d2 = {']': '[', '}': '{', ')': '('}
    stack = []
    for i, c in enumerate(s):
        if c in d1:
            stack.append((i,c))
        if c in d2 and (not stack or d2[c] != stack.pop()[1]):
            return i + 1
    if stack:
        return stack[-1][0] + 1
    return 0


def main():
    s = input()
    ans = check_parenthesis(s)
    if ans == 0:
        print('Success')
    else:
        print(ans)


if __name__ == '__main__':
    main()
